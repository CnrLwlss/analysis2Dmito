MCMCout = 1000,
MCMCthin = 1000,
parameterVals = paramVals
)
}
stopCluster(cl)
for( root in names(output) ){
list_saver(output[[root]], file.path("Output", root), nameSep="__")
}
}
library("data.table")
library("dplyr")
library("readr")
library("tidyr")
library("rjags")
library("parallel")
# install.packages("devtools")
library("devtools")
devtools::install_github("jordanbchilds/analysis2Dmito")
library("analysis2Dmito")
data_raw = get_exampleData()
data = data_raw
data$value = log( data_raw$value )
sbj = unique(data$sampleID)
ctrlIDs = grep("C", sbj, value=TRUE)
pts = sort( sbj[!(sbj %in% ctrlIDs)] )
# measure of mass (x-axis in 2Dmito)
mitochan = "VDAC"
# proteins of interest (y-axis in 2Dmito)
channels_all = unique(data$channel)
channels = channels_all[channels_all != mitochan]
slopes = matrix(NA, nrow=length(channels), ncol=length(ctrlIDs))
rownames(slopes) = channels
colnames(slopes) = ctrlIDs
intercepts = slopes # defines an empty matrix with row and col names as wanted
precisions = slopes
for(chan in channels){
for(crl in ctrlIDs){
x = data[data$sampleID==crl & data$channel==mitochan, "value"]
y = data[data$sampleID==crl & data$channel==chan, "value"]
df = data.frame(mitochan=x, chan=y)
lnmod = lm(chan~mitochan, data=df)
slopes[chan, crl] = lnmod$coefficients["mitochan"]
intercepts[chan, crl] = lnmod$coefficients["(Intercept)"]
precisions[chan, crl] = 1 / summary(lnmod)$sigma^2
}
}
slope_mean = apply(slopes, 1, mean)
inter_mean = apply(intercepts, 1, mean)
prec_mean = apply(precisions, 1, mean)
slope_var = apply(slopes, 1, var)
inter_var = apply(intercepts, 1, var)
prec_var = apply(precisions, 1, var)
dir.create("Output")
for( chan in channels ){
data_list = list()
for(pat in pts){
data_list[[paste(chan, pat, sep="_")]] = getData_mats(data,
pts=pat,
channels=c(mitochan, chan),
ctrlID=ctrlIDs)
}
mean_mu_m = slope_mean[chan]
prec_mu_m = 1 / 0.05 ^ 2
mean_mu_c = inter_chan[chan]
prec_mu_c = 1 / 0.05 ^ 2
tau_m_mode = 1 / slope_var[chan]
tau_m_var = 1
rate_tau_m = 0.5 * (tau_m_mode + sqrt(tau_m_mode ^ 2 + 4 * tau_m_var)) / tau_m_var
shape_tau_m = 1 + tau_m_mode * rate_tau_m
tau_c_mode = 1 / inter_var[chan]
tau_c_var = 1
rate_tau_c = 0.5 * (tau_c_mode + sqrt(tau_c_mode ^ 2 + 4 * tau_c_var)) / tau_c_var
shape_tau_c = 1 + tau_c_mode * rate_tau_c
tau_mode = prec_mean[chan]
tau_var = 1
rate_tau = 0.5 * (tau_mode + sqrt(tau_mode ^ 2 + 4 * tau_var)) / tau_var
shape_tau = 1 + tau_mode * rate_tau
tau_def = 0.0001
paramVals = list(
mean_mu_m = mean_mu_m,
prec_mu_m = prec_mu_m,
mean_mu_c = mean_mu_c,
prec_mu_c = prec_mu_c,
shape_tau_m = shape_tau_m,
rate_tau_m = rate_tau_m,
shape_tau_c = shape_tau_c,
rate_tau_c = rate_tau_c,
rate_tau = rate_tau,
shape_tau=rate_tau,
tau_def = tau_def
)
ncores = 6
cl  = makeCluster(ncores)
{
output = parLapply(
cl,
data_list,
inference,
MCMCburnin = 10,
MCMCout = 1000,
MCMCthin = 1000,
parameterVals = paramVals
)
}
stopCluster(cl)
for( root in names(output) ){
list_saver(output[[root]], file.path("Output", root), nameSep="__")
}
}
library("data.table")
library("dplyr")
library("readr")
library("tidyr")
library("rjags")
library("parallel")
# install.packages("devtools")
library("devtools")
devtools::install_github("jordanbchilds/analysis2Dmito")
library("analysis2Dmito")
data_raw = get_exampleData()
data = data_raw
data$value = log( data_raw$value )
sbj = unique(data$sampleID)
ctrlIDs = grep("C", sbj, value=TRUE)
pts = sort( sbj[!(sbj %in% ctrlIDs)] )
# measure of mass (x-axis in 2Dmito)
mitochan = "VDAC"
# proteins of interest (y-axis in 2Dmito)
channels_all = unique(data$channel)
channels = channels_all[channels_all != mitochan]
slopes = matrix(NA, nrow=length(channels), ncol=length(ctrlIDs))
rownames(slopes) = channels
colnames(slopes) = ctrlIDs
intercepts = slopes # defines an empty matrix with row and col names as wanted
precisions = slopes
for(chan in channels){
for(crl in ctrlIDs){
x = data[data$sampleID==crl & data$channel==mitochan, "value"]
y = data[data$sampleID==crl & data$channel==chan, "value"]
df = data.frame(mitochan=x, chan=y)
lnmod = lm(chan~mitochan, data=df)
slopes[chan, crl] = lnmod$coefficients["mitochan"]
intercepts[chan, crl] = lnmod$coefficients["(Intercept)"]
precisions[chan, crl] = 1 / summary(lnmod)$sigma^2
}
}
slope_mean = apply(slopes, 1, mean)
inter_mean = apply(intercepts, 1, mean)
prec_mean = apply(precisions, 1, mean)
slope_var = apply(slopes, 1, var)
inter_var = apply(intercepts, 1, var)
prec_var = apply(precisions, 1, var)
dir.create("Output")
for( chan in channels ){
data_list = list()
for(pat in pts){
data_list[[paste(chan, pat, sep="_")]] = getData_mats(data,
pts=pat,
channels=c(mitochan, chan),
ctrlID=ctrlIDs)
}
mean_mu_m = slope_mean[chan]
prec_mu_m = 1 / 0.05 ^ 2
mean_mu_c = inter_mean[chan]
prec_mu_c = 1 / 0.05 ^ 2
tau_m_mode = 1 / slope_var[chan]
tau_m_var = 1
rate_tau_m = 0.5 * (tau_m_mode + sqrt(tau_m_mode ^ 2 + 4 * tau_m_var)) / tau_m_var
shape_tau_m = 1 + tau_m_mode * rate_tau_m
tau_c_mode = 1 / inter_var[chan]
tau_c_var = 1
rate_tau_c = 0.5 * (tau_c_mode + sqrt(tau_c_mode ^ 2 + 4 * tau_c_var)) / tau_c_var
shape_tau_c = 1 + tau_c_mode * rate_tau_c
tau_mode = prec_mean[chan]
tau_var = 1
rate_tau = 0.5 * (tau_mode + sqrt(tau_mode ^ 2 + 4 * tau_var)) / tau_var
shape_tau = 1 + tau_mode * rate_tau
tau_def = 0.0001
paramVals = list(
mean_mu_m = mean_mu_m,
prec_mu_m = prec_mu_m,
mean_mu_c = mean_mu_c,
prec_mu_c = prec_mu_c,
shape_tau_m = shape_tau_m,
rate_tau_m = rate_tau_m,
shape_tau_c = shape_tau_c,
rate_tau_c = rate_tau_c,
rate_tau = rate_tau,
shape_tau=rate_tau,
tau_def = tau_def
)
ncores = 6
cl  = makeCluster(ncores)
{
output = parLapply(
cl,
data_list,
inference,
MCMCburnin = 10,
MCMCout = 1000,
MCMCthin = 1000,
parameterVals = paramVals
)
}
stopCluster(cl)
for( root in names(output) ){
list_saver(output[[root]], file.path("Output", root), nameSep="__")
}
}
library("devtools")
#install_github("jordanbchilds/analysis2Dmito", force=TRUE)
library(analysis2Dmito)
data_raw = get_exampleData()
data = data_raw
data$value = log( data_raw$value )
sbj = unique(data$sampleID)
ctrlIDs = grep("C", sbj, value=TRUE)
pts = sort( sbj[!(sbj %in% ctrlIDs)] )
# measure of mass (x-axis in 2Dmito)
mitochan = "VDAC"
# proteins of interest (y-axis in 2Dmito)
channels_all = unique(data$channel)
channels = channels_all[channels_all != mitochan]
dir.create(file.path("PDF"), showWarnings = FALSE)
# ------ MCMC plot
pdf(file.path("PDF", "MCMCplot.pdf"), width=13, height=8)
{
for(chan in channels){
for(pat in pts) {
outroot = paste(chan, pat, sep="_")
fn_post = file.path("Output", paste0(outroot, "__POST.txt"))
if(file.exists(fn_post)){
post = as.data.frame(fread(fn_post))
fn_prior = file.path("Output", paste0(outroot, "__PRIOR.txt"))
prior = as.data.frame(fread(fn_prior))
analysis2Dmito::MCMCplot(post, prior, nRow=3, lag=100)
title(main=paste(chan, pat), outer=TRUE, line=-1)
}
}
}
}
dev.off()
# ------ postPlot
pdf(file.path("PDF", "postPlot.pdf"), width=13, height=8)
{
for(chan in channels){
for( pat in pts ){
outroot = paste(chan, pat, sep="_")
fn_post = file.path("Output", paste0(outroot, "__POST.txt"))
if(file.exists(fn_post)){
post = as.data.frame(fread(fn_post))
fn_prior = file.path("Output", paste0(outroot, "__PRIOR.txt"))
prior = as.data.frame(fread(fn_prior))
fn_postpred = file.path("Output", paste0(outroot, "__POSTPRED.txt"))
postpred = as.data.frame(fread(fn_postpred))
fn_class = file.path("Output", paste0(outroot, "__CLASSIF.txt"))
class = apply(as.matrix(fread(fn_class)), 2, mean)
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
op = par(mfrow=c(3,3), mar=c(4,4,3,3), cex.main=2, cex.lab=1.5, cex.axis=1.5)
analysis2Dmito::postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
title(main=paste(chan, pat), outer=TRUE, line=-2)
par(op)
}
}
}
}
dev.off()
# ------ Classif plot
pdf(file.path("PDF", "classif.pdf"), width=8, height=5)
{
op = par(mfrow=c(1,1), mar=c(6,6,3,3), cex.main=2, cex.axis=1.5, cex.lab=2)
for(chan in channels){
for( pat in pts ){
outroot = paste(chan, pat, sep="_")
fn_class = file.path("Output", paste0(outroot, "__CLASSIF.txt"))
if(file.exists(fn_class)){
class = apply(as.matrix(fread(fn_class)), 2, mean)
fn_postpred = file.path("Output", paste0(outroot, "__POSTPRED.txt"))
postpred = as.data.frame(fread(fn_postpred))
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
analysis2Dmito::classif_plot(dataMats=dataMats,
postpred=NULL,
classifs=class,
xlab=paste0("log(", mitochan, ")"),
ylab=paste0("log(", chan, ")"))
}
}
}
par(op)
}
dev.off()
dev.off()
dev.off()
inter_var
prec_mean
library("data.table")
library("dplyr")
library("readr")
library("tidyr")
library("rjags")
library("parallel")
# install.packages("devtools")
library("devtools")
devtools::install_github("jordanbchilds/analysis2Dmito")
library("analysis2Dmito")
data_raw = get_exampleData()
data = data_raw
data$value = log( data_raw$value )
sbj = unique(data$sampleID)
ctrlIDs = grep("C", sbj, value=TRUE)
pts = sort( sbj[!(sbj %in% ctrlIDs)] )
# measure of mass (x-axis in 2Dmito)
mitochan = "VDAC"
# proteins of interest (y-axis in 2Dmito)
channels_all = unique(data$channel)
channels = channels_all[channels_all != mitochan]
slopes = matrix(NA, nrow=length(channels), ncol=length(ctrlIDs))
rownames(slopes) = channels
colnames(slopes) = ctrlIDs
intercepts = slopes # defines an empty matrix with row and col names as wanted
precisions = slopes
for(chan in channels){
for(crl in ctrlIDs){
x = data[data$sampleID==crl & data$channel==mitochan, "value"]
y = data[data$sampleID==crl & data$channel==chan, "value"]
df = data.frame(mitochan=x, chan=y)
lnmod = lm(chan~mitochan, data=df)
slopes[chan, crl] = lnmod$coefficients["mitochan"]
intercepts[chan, crl] = lnmod$coefficients["(Intercept)"]
precisions[chan, crl] = 1 / summary(lnmod)$sigma^2
}
}
slope_mean = apply(slopes, 1, mean)
inter_mean = apply(intercepts, 1, mean)
prec_mean = apply(precisions, 1, mean)
slope_var = apply(slopes, 1, var)
inter_var = apply(intercepts, 1, var)
prec_var = apply(precisions, 1, var)
dir.create("Output")
for( chan in channels ){
data_list = list()
for(pat in pts){
data_list[[paste(chan, pat, sep="_")]] = getData_mats(data,
pts=pat,
channels=c(mitochan, chan),
ctrlID=ctrlIDs)
}
mean_mu_m = slope_mean[chan]
prec_mu_m = 1 / 0.05 ^ 2
mean_mu_c = inter_mean[chan]
prec_mu_c = 1 / 0.05 ^ 2
tau_m_mode = 1 / slope_var[chan]
tau_m_var = 1
rate_tau_m = 0.5 * (tau_m_mode + sqrt(tau_m_mode ^ 2 + 4 * tau_m_var)) / tau_m_var
shape_tau_m = 1 + tau_m_mode * rate_tau_m
tau_c_mode = 1 / inter_var[chan]
tau_c_var = 1
rate_tau_c = 0.5 * (tau_c_mode + sqrt(tau_c_mode ^ 2 + 4 * tau_c_var)) / tau_c_var
shape_tau_c = 1 + tau_c_mode * rate_tau_c
tau_mode = prec_mean[chan]
tau_var = 1
rate_tau = 0.5 * (tau_mode + sqrt(tau_mode ^ 2 + 4 * tau_var)) / tau_var
shape_tau = 1 + tau_mode * rate_tau
tau_def = 0.0001
paramVals = list(
mean_mu_m = mean_mu_m,
prec_mu_m = prec_mu_m,
mean_mu_c = mean_mu_c,
prec_mu_c = prec_mu_c,
shape_tau_m = shape_tau_m,
rate_tau_m = rate_tau_m,
shape_tau_c = shape_tau_c,
rate_tau_c = rate_tau_c,
rate_tau = rate_tau,
shape_tau = shape_tau,
tau_def = tau_def
)
ncores = 6
cl  = makeCluster(ncores)
{
output = parLapply(
cl,
data_list,
inference,
MCMCburnin = 10,
MCMCout = 1000,
MCMCthin = 1000,
parameterVals = paramVals
)
}
stopCluster(cl)
for( root in names(output) ){
list_saver(output[[root]], file.path("Output", root), nameSep="__")
}
}
library("devtools")
#install_github("jordanbchilds/analysis2Dmito", force=TRUE)
library(analysis2Dmito)
data_raw = get_exampleData()
data = data_raw
data$value = log( data_raw$value )
sbj = unique(data$sampleID)
ctrlIDs = grep("C", sbj, value=TRUE)
pts = sort( sbj[!(sbj %in% ctrlIDs)] )
# measure of mass (x-axis in 2Dmito)
mitochan = "VDAC"
# proteins of interest (y-axis in 2Dmito)
channels_all = unique(data$channel)
channels = channels_all[channels_all != mitochan]
dir.create(file.path("PDF"), showWarnings = FALSE)
# ------ MCMC plot
pdf(file.path("PDF", "MCMCplot.pdf"), width=13, height=8)
{
for(chan in channels){
for(pat in pts) {
outroot = paste(chan, pat, sep="_")
fn_post = file.path("Output", paste0(outroot, "__POST.txt"))
if(file.exists(fn_post)){
post = as.data.frame(fread(fn_post))
fn_prior = file.path("Output", paste0(outroot, "__PRIOR.txt"))
prior = as.data.frame(fread(fn_prior))
analysis2Dmito::MCMCplot(post, prior, nRow=3, lag=100)
title(main=paste(chan, pat), outer=TRUE, line=-1)
}
}
}
}
dev.off()
# ------ postPlot
pdf(file.path("PDF", "postPlot.pdf"), width=13, height=8)
{
for(chan in channels){
for( pat in pts ){
outroot = paste(chan, pat, sep="_")
fn_post = file.path("Output", paste0(outroot, "__POST.txt"))
if(file.exists(fn_post)){
post = as.data.frame(fread(fn_post))
fn_prior = file.path("Output", paste0(outroot, "__PRIOR.txt"))
prior = as.data.frame(fread(fn_prior))
fn_postpred = file.path("Output", paste0(outroot, "__POSTPRED.txt"))
postpred = as.data.frame(fread(fn_postpred))
fn_class = file.path("Output", paste0(outroot, "__CLASSIF.txt"))
class = apply(as.matrix(fread(fn_class)), 2, mean)
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
op = par(mfrow=c(3,3), mar=c(4,4,3,3), cex.main=2, cex.lab=1.5, cex.axis=1.5)
analysis2Dmito::postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
title(main=paste(chan, pat), outer=TRUE, line=-2)
par(op)
}
}
}
}
dev.off()
# ------ Classif plot
pdf(file.path("PDF", "classif.pdf"), width=8, height=5)
{
op = par(mfrow=c(1,1), mar=c(6,6,3,3), cex.main=2, cex.axis=1.5, cex.lab=2)
for(chan in channels){
for( pat in pts ){
outroot = paste(chan, pat, sep="_")
fn_class = file.path("Output", paste0(outroot, "__CLASSIF.txt"))
if(file.exists(fn_class)){
class = apply(as.matrix(fread(fn_class)), 2, mean)
fn_postpred = file.path("Output", paste0(outroot, "__POSTPRED.txt"))
postpred = as.data.frame(fread(fn_postpred))
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
analysis2Dmito::classif_plot(dataMats=dataMats,
postpred=NULL,
classifs=class,
xlab=paste0("log(", mitochan, ")"),
ylab=paste0("log(", chan, ")"))
}
}
}
par(op)
}
dev.off()
channels
build()
library("devtools")
build()
load_all()
rlang::last_trace()
rlang::last_trace(drop = FALSE)
load_all()
?colors
colors()
