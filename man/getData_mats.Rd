% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getData_mats.R
\name{getData_mats}
\alias{getData_mats}
\title{Data preparation for \code{\link[=inference]{inference()}}.}
\usage{
getData_mats(
  data,
  channels,
  ctrlID,
  pts = NULL,
  ctrl_only = FALSE,
  getIndex = FALSE
)
}
\arguments{
\item{data}{A data.frame object of the protein expression data. See details for the format the data should be in to be able to parse to the data.}

\item{channels}{A vector of strings or a single string containing the channels which will form the columns of the returned matrix.}

\item{ctrlID}{A character vector denoting the ID for the control samples in the 'sampleID' column of data.}

\item{pts}{A vector of subject names or a single subject name, whose expression levels are wished to be returned. The defualt value is NULL, if this is the case the protein expression levels for all subjects within the dataset are returned.}

\item{ctrl_only}{A boolean variable indicating whether to return only patient data, the default is FALSE. If this is TRUE and getIndex=FALSE the function will return a single matrix otherwise it will return a list containing all outputs.}

\item{getINDEX}{A boolean parameter, if TRUE two vectors of indexes, one for the control data and one for the patient data, are returned. Each indicating which observations came from the same sample by grouping them from 1 upto the number of samples in the data requested. The default is FALSE.}
}
\value{
If ctrl_only=TRUE and getIndex=FALSE then a matrix is returned of just the control sample fibre expressiosn. The columns of the matrix correspond to the channels requested. Otherwise a list is returned containing the requested elements.
\itemize{
\item ctrl : The control sample data matrix.
\item pts : The patient sample data matrix.
\item indexCtrl : A vector of control sample indexes.
\item indexPts : A vector of patient sample indexes.
}
}
\description{
The function aggregates the data into the form needed for \link{inference}. To be able to do this the data passed to the function must in a specific form, see details for more info.
The data.frame object passed to the function must be in long form and have the following columns; 'value', 'channel', 'sampleID' and 'fibreID'. Where 'value' is the protein expression value, 'channel' is the protein or channel that the value expresses, 'sampleID' is the identifying name associated with the sample the expression is from and'fibreID' is the fibre identification from that sample. Other columns can be present but are not needed.
To be able to transform the data into long form, we suggest using the \link{tidyverse} package and the \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}} function.
}
\examples{
data(exampleData)
# the measure of mitochondrial mass - the x-axis of the 2D mito plot
mitochan = "raw_porin"

# all channels available in the dataset
channelsAll = unique(exampleData[,"channel"])
# remove mitochan from the channels of interest
channels = channelsAll[ channelsAll!=mitochan ]
sbj = unique(exampleData$sampleID)
ctrlid = c("C01", "C02", "C03", "C04", "C05")
pts = sbj[ !(sbj \%in\% ctrlid) ]
chan = channels[1]
pat = pts[1]
data_mat = getData_mats(exampleData, cord=c(mitochan, chan), ctrlID=ctrlid, pts=pat, getIndex=TRUE)

}
